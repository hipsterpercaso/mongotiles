// Generated by CoffeeScript 1.6.3
/*
#
# Copyright (C) 2013 by Vaughn Iverson
# 
# mongotiles
#
# With this you can use MongoDB GridFS as a "tilelive.js" source or sink for 
# map tile / grid / tilejson data.
#
# See: https://github.com/mapbox/tilelive.js
#
# License:
#
# This project is free software released under the MIT/X11 license:
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#
*/


(function() {
  var Tilemongo, default_root, fs, get_mime_type, grid_name, mongodb, path, protocol, tile_name, tilejson_name, tilelive, url;

  path = require('path');

  fs = require('fs');

  url = require('url');

  tilelive = require('tilelive');

  mongodb = require('mongodb');

  protocol = 'mongotiles';

  default_root = 'fs';

  tile_name = function(z, x, y) {
    var name;
    if ((x != null) && (y != null) && (z != null)) {
      return name = "tile_" + z + "_" + x + "_" + y;
    } else {
      return name = 'tile_{z}_{x}_{y}';
    }
  };

  grid_name = function(z, x, y) {
    var name;
    if ((x != null) && (y != null) && (z != null)) {
      return name = "grid_" + z + "_" + x + "_" + y;
    } else {
      return name = 'grid_{z}_{x}_{y}';
    }
  };

  tilejson_name = "tilejson.json";

  get_mime_type = function(bytes) {
    if (bytes[0] === 0x89 && bytes[1] === 0x50 && bytes[2] === 0x4E && bytes[3] === 0x47 && bytes[4] === 0x0D && bytes[5] === 0x0A && bytes[6] === 0x1A && bytes[7] === 0x0A) {
      return 'image/png';
    } else if (bytes[0] === 0xFF && bytes[1] === 0xD8 && bytes[bytes.length - 2] === 0xFF && bytes[bytes.length - 1] === 0xD9) {
      return 'image/jpeg';
    } else if (bytes[0] === 0x47 && bytes[1] === 0x49 && bytes[2] === 0x46 && bytes[3] === 0x38 && (bytes[4] === 0x39 || bytes[4] === 0x37) && bytes[5] === 0x61) {
      return 'image/gif';
    } else {
      console.warn("tilecouch: Image data with unknown MIME type in putTile call to get_mime_type.");
      return 'application/octet-stream';
    }
  };

  Tilemongo = (function() {
    Tilemongo.prototype._write_buffer = function(fn, type, buffer, cb) {
      var gs,
        _this = this;
      gs = new mongodb.GridStore(this.db, fn, 'w', {
        root: this.grid_root,
        content_type: type
      });
      return gs.open(function(err, gs) {
        if (err) {
          return cb(err);
        }
        return gs.write(buffer, function(err, gs) {
          if (err) {
            return cb(err);
          }
          return gs.close(cb);
        });
      });
    };

    Tilemongo.prototype._read_buffer = function(fn, cb) {
      var _this = this;
      return mongodb.GridStore.exist(this.db, fn, this.grid_root, {}, function(err, exists) {
        var gs;
        if (err) {
          return cb(err);
        }
        if (!exists) {
          return cb(null, null);
        }
        gs = new mongodb.GridStore(_this.db, fn, 'r', {
          root: _this.grid_root
        });
        return gs.open(function(err, gs) {
          if (err) {
            return cb(err);
          }
          return gs.read(function(err, buffer) {
            if (err) {
              return cb(err);
            }
            return gs.close(function(err) {
              return cb(err, buffer);
            });
          });
        });
      });
    };

    Tilemongo.registerProtocols = function(tilelive) {
      return tilelive.protocols["" + protocol + ":"] = this;
    };

    Tilemongo.list = function(filepath, callback) {
      return callback(new Error(".list not implemented for " + protocol));
    };

    Tilemongo.findID = function(filepath, id, callback) {
      return callback(new Error(".findID not implemented for " + protocol));
    };

    function Tilemongo(uri, callback) {
      var tile_url, tilepath_match, _ref,
        _this = this;
      this.starts = 0;
      tile_url = url.parse(uri);
      if (tile_url.protocol !== ("" + protocol + ":")) {
        return callback(new Error("Bad uri protocol '" + tile_url.protocol + "'.  Must be " + protocol + "."));
      }
      tilepath_match = tile_url.pathname.match(new RegExp("(/[^/]+/)([^/]+/)?"));
      if (!tilepath_match) {
        return callback(new Error("Bad tile url path '" + tile_url.pathname + "' for " + protocol + "."));
      }
      tile_url.query = '';
      tile_url.search = '';
      tile_url.hash = '';
      tile_url.protocol = 'http:';
      this.source = url.format(tile_url);
      this.db_name = tilepath_match[1].slice(1, -1);
      this.grid_root = ((_ref = tilepath_match[2]) != null ? _ref.slice(0, -1) : void 0) || default_root;
      tile_url.path = tilepath_match[1];
      tile_url.pathname = tile_url.path;
      tile_url.protocol = 'mongodb:';
      this.server = url.format(tile_url);
      mongodb.MongoClient.connect(this.server, function(err, db) {
        if (err) {
          return callback(err);
        }
        _this.db = db;
        return callback(null, _this);
      });
    }

    Tilemongo.prototype.close = function(callback) {
      this.db.close();
      return callback(null);
    };

    Tilemongo.prototype.getInfo = function(callback) {
      var _this = this;
      return this._read_buffer(tilejson_name, function(err, info) {
        if (err) {
          return callback(err);
        }
        return callback(null, JSON.parse(info));
      });
    };

    Tilemongo.prototype.getTile = function(z, x, y, callback) {
      var tn,
        _this = this;
      tn = tile_name(z, x, y);
      return this._read_buffer(tn, function(err, data) {
        if (err) {
          return callback(err);
        } else if (!data) {
          return callback(new Error('Tile does not exist'));
        } else {
          return callback(null, data);
        }
      });
    };

    Tilemongo.prototype.getGrid = function(z, x, y, callback) {
      var gn,
        _this = this;
      gn = grid_name(z, x, y);
      return this._read_buffer(gn, function(err, data) {
        if (err) {
          return callback(err);
        } else if (!data) {
          return callback(new Error('Grid does not exist'));
        } else {
          return callback(null, JSON.parse(data));
        }
      });
    };

    Tilemongo.prototype.startWriting = function(callback) {
      this.starts += 1;
      return callback(null);
    };

    Tilemongo.prototype.stopWriting = function(callback) {
      this.starts -= 1;
      return callback(null);
    };

    Tilemongo.prototype.putInfo = function(info, callback) {
      var gn, tn;
      if (!this.starts) {
        return callback(new Error("Error, writing not started."));
      }
      tn = tile_name();
      info.tiles = ["" + this.source + tn];
      if (info.grids != null) {
        gn = grid_name();
        info.grids = ["" + this.source + gn];
      }
      return this._write_buffer(tilejson_name, 'application/json', JSON.stringify(info), callback);
    };

    Tilemongo.prototype.putTile = function(z, x, y, tile, callback) {
      var tn, type;
      if (!this.starts) {
        return callback(new Error("Error, writing not started."));
      }
      tn = tile_name(z, x, y);
      type = get_mime_type(tile);
      return this._write_buffer(tn, type, tile, callback);
    };

    Tilemongo.prototype.putGrid = function(z, x, y, grid, callback) {
      var gn;
      if (!this.starts) {
        return callback(new Error("Error, writing not started."));
      }
      gn = grid_name(z, x, y);
      return this._write_buffer(gn, 'application/json', JSON.stringify(grid), callback);
    };

    return Tilemongo;

  })();

  module.exports = Tilemongo;

}).call(this);
