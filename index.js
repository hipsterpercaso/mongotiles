// Generated by CoffeeScript 1.7.1

/*
 *
 * Copyright (C) 2013-2014 by Vaughn Iverson
 *
 * mongotiles
 *
 * With this you can use MongoDB GridFS as a "tilelive.js" source or sink for
 * map tile / grid / tilejson data.
 *
 * See: https://github.com/mapbox/tilelive.js
 *
 * License:
 *
 * This project is free software released under the MIT/X11 license:
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 *
 */

(function() {
  var Lock, LockCollection, Tilemongo, default_root, fs, get_mime_type, grid_name, mongodb, path, protocol, tile_name, tilejson_name, tilelive, url;

  path = require('path');

  fs = require('fs');

  url = require('url');

  tilelive = require('tilelive');

  mongodb = require('mongodb');

  LockCollection = require('grid-locks').LockCollection;

  Lock = require('grid-locks').Lock;

  protocol = 'mongotiles';

  default_root = 'fs';

  tile_name = function(z, x, y) {
    var name;
    if ((x != null) && (y != null) && (z != null)) {
      return name = "tile_" + z + "_" + x + "_" + y;
    } else {
      return name = 'tile_{z}_{x}_{y}';
    }
  };

  grid_name = function(z, x, y) {
    var name;
    if ((x != null) && (y != null) && (z != null)) {
      return name = "grid_" + z + "_" + x + "_" + y;
    } else {
      return name = 'grid_{z}_{x}_{y}';
    }
  };

  tilejson_name = "tilejson.json";

  get_mime_type = function(bytes) {
    if (bytes[0] === 0x89 && bytes[1] === 0x50 && bytes[2] === 0x4E && bytes[3] === 0x47 && bytes[4] === 0x0D && bytes[5] === 0x0A && bytes[6] === 0x1A && bytes[7] === 0x0A) {
      return 'image/png';
    } else if (bytes[0] === 0xFF && bytes[1] === 0xD8 && bytes[bytes.length - 2] === 0xFF && bytes[bytes.length - 1] === 0xD9) {
      return 'image/jpeg';
    } else if (bytes[0] === 0x47 && bytes[1] === 0x49 && bytes[2] === 0x46 && bytes[3] === 0x38 && (bytes[4] === 0x39 || bytes[4] === 0x37) && bytes[5] === 0x61) {
      return 'image/gif';
    } else {
      console.warn("" + protocol + ": Image data with unknown MIME type in putTile call to get_mime_type.");
      return 'application/octet-stream';
    }
  };

  Tilemongo = (function() {
    Tilemongo.prototype._write_buffer = function(fn, type, buffer, metadata, cb) {
      var gs;
      gs = new mongodb.GridStore(this.db, fn, 'w', {
        root: this.grid_root,
        content_type: type,
        metadata: metadata
      });
      return gs.open((function(_this) {
        return function(err, gs) {
          if (err) {
            return cb(err);
          }
          return gs.write(buffer, function(err, gs) {
            if (err) {
              return cb(err);
            }
            return gs.close(cb);
          });
        };
      })(this));
    };

    Tilemongo.prototype._read_buffer = function(fn, cb) {
      return mongodb.GridStore.exist(this.db, fn, this.grid_root, {}, (function(_this) {
        return function(err, exists) {
          var gs;
          if (err) {
            return cb(err);
          }
          if (!exists) {
            return cb(null, null);
          }
          gs = new mongodb.GridStore(_this.db, fn, 'r', {
            root: _this.grid_root
          });
          return gs.open(function(err, gs) {
            if (err) {
              return cb(err);
            }
            return gs.read(function(err, buffer) {
              if (err) {
                return cb(err);
              }
              return gs.close(function(err) {
                return cb(err, buffer);
              });
            });
          });
        };
      })(this));
    };

    Tilemongo.registerProtocols = function(tilelive) {
      return tilelive.protocols["" + protocol + ":"] = this;
    };

    Tilemongo.list = function(filepath, callback) {
      return callback(new Error(".list not implemented for " + protocol));
    };

    Tilemongo.findID = function(filepath, id, callback) {
      return callback(new Error(".findID not implemented for " + protocol));
    };

    function Tilemongo(uri, callback) {
      var tile_url, tilepath_match, _ref;
      this.starts = 0;
      tile_url = url.parse(uri);
      if (!(tile_url.protocol === ("" + protocol + ":") || tile_url.protocol === ("locking" + protocol + ":"))) {
        return callback(new Error("Bad uri protocol '" + tile_url.protocol + "'.  Must be " + protocol + " or locking" + protocol + "."));
      }
      tilepath_match = tile_url.pathname.match(new RegExp("(/[^/]+/)([^/]+/)?"));
      if (!tilepath_match) {
        return callback(new Error("Bad tile url path '" + tile_url.pathname + "' for " + tile_url.protocol + "."));
      }
      tile_url.query = '';
      tile_url.search = '';
      tile_url.hash = '';
      tile_url.protocol = 'http:';
      this.source = url.format(tile_url);
      this.db_name = tilepath_match[1].slice(1, -1);
      this.grid_root = ((_ref = tilepath_match[2]) != null ? _ref.slice(0, -1) : void 0) || default_root;
      tile_url.path = tilepath_match[1];
      tile_url.pathname = tile_url.path;
      tile_url.protocol = 'mongodb:';
      this.server = url.format(tile_url);
      mongodb.MongoClient.connect(this.server, (function(_this) {
        return function(err, db) {
          if (err) {
            return callback(err);
          }
          _this.db = db;
          return callback(null, _this);
        };
      })(this));
    }

    Tilemongo.prototype.close = function(callback) {
      this.db.close();
      return callback(null);
    };

    Tilemongo.prototype.getInfo = function(callback) {
      return this._read_buffer(tilejson_name, (function(_this) {
        return function(err, info) {
          if (err) {
            return callback(err);
          }
          return callback(null, JSON.parse(info));
        };
      })(this));
    };

    Tilemongo.prototype.getTile = function(z, x, y, callback) {
      var tn;
      tn = tile_name(z, x, y);
      return this._read_buffer(tn, (function(_this) {
        return function(err, data) {
          if (err) {
            return callback(err);
          } else if (!data) {
            return callback(new Error('Tile does not exist'));
          } else {
            return callback(null, data);
          }
        };
      })(this));
    };

    Tilemongo.prototype.getGrid = function(z, x, y, callback) {
      var gn;
      gn = grid_name(z, x, y);
      return this._read_buffer(gn, (function(_this) {
        return function(err, data) {
          if (err) {
            return callback(err);
          } else if (!data) {
            return callback(new Error('Grid does not exist'));
          } else {
            return callback(null, JSON.parse(data));
          }
        };
      })(this));
    };

    Tilemongo.prototype.startWriting = function(callback) {
      this.starts += 1;
      return callback(null);
    };

    Tilemongo.prototype.stopWriting = function(callback) {
      this.starts -= 1;
      return callback(null);
    };

    Tilemongo.prototype.putInfo = function(info, callback) {
      var gn, tn;
      if (!this.starts) {
        return callback(new Error("Error, writing not started."));
      }
      tn = tile_name();
      info.tiles = ["" + this.source + tn];
      if (info.grids != null) {
        gn = grid_name();
        info.grids = ["" + this.source + gn];
      }
      return this._write_buffer(tilejson_name, 'application/json', JSON.stringify(info), null, callback);
    };

    Tilemongo.prototype.putTile = function(z, x, y, tile, callback) {
      var tn, type;
      if (!this.starts) {
        return callback(new Error("Error, writing not started."));
      }
      tn = tile_name(z, x, y);
      type = get_mime_type(tile);
      return this._write_buffer(tn, type, tile, {
        type: "tile",
        x: x,
        y: y,
        z: z
      }, callback);
    };

    Tilemongo.prototype.putGrid = function(z, x, y, grid, callback) {
      var gn;
      if (!this.starts) {
        return callback(new Error("Error, writing not started."));
      }
      gn = grid_name(z, x, y);
      return this._write_buffer(gn, 'application/json', JSON.stringify(grid), {
        type: "grid",
        x: x,
        y: y,
        z: z
      }, callback);
    };

    return Tilemongo;

  })();

  module.exports = Tilemongo;

}).call(this);
